#!/usr/bin/python

# jk 21.10.2025

import ROOT
from math import pow, log10, pow, sqrt

import os, sys

from utils import *
from consts import *

########################################

cans = []
stuff = []
txts = []        


########################################
def GetScalarSum(h):
    val = 0.
    for i in range(1,h.GetXaxis().GetNbins()+1):
        x = h.GetBinCenter(i)
        y = h.GetBinContent(i)
        val += x*y
    return val
    

########################################
def GetMeanAndError(means):
    meanSqSum = 0
    np = len(means)
    meanMean = sum(means) / np
    for i in range(0, len(means)):
        meanSqSum += pow(means[i] - meanMean, 2)
    meanErr = 0.
    if np > 1 and meanSqSum > 0:
        meanErr = sqrt(meanSqSum / (np - 1) / np)
        
    return meanMean, meanErr

########################################

def GetHintegrals(logEs, fnames, hbasenames, Nshowers, debug = 1):
    Fs = []
    Hs = {}
    Means = {}
    Rebin = 4
        
    for logE in logEs:
        infile = None
        fname = fnames[logE]
        infile = ROOT.TFile(fname, 'read')
        Fs.append(infile)
        Hs[logE] = {}
        
        fracs = []
        for i in range(0,Nshowers):
            integrals = {}
            for hbasename  in hbasenames:
                hname = hbasename + f'_{i}'
                h = infile.Get(hname)
                try:
                    integral = GetScalarSum(h) #h.GetMean() #Integral() #GetBinCenter(h.GetMaximumBin()) #h.GetMean()
                    err = 0 #h.GetMeanError()
                    integrals[hbasename] = integral
                    print(f'{i} {hbasename} I={integral}')
                    h.Rebin(Rebin)
                    #if logE < 10e4:
                    #    h.Rebin(2)
                    try:
                        Hs[logE][hbasename].append(h)
                    except:
                        Hs[logE][hbasename] = h
                except:
                    if debug: 
                        print(f'Error getting {hname} from {fname}')
                    pass
            key1, key2 = '', ''
            for key in hbasenames:
                if 'Nch' in key:
                    key2 = key + ''
                if 'Npi0' in key:
                    key1 = key + ''
            print('integrals: ', integrals)
            try:
                # compute the EM fraction in terms of the number of pi0 / (npi0 + ncharged)
                frac = integrals[key1] / ( integrals[key2] + integrals[key1])
                print(f' shower {i} Em frac: {frac}')
                fracs.append(frac)
            except:
                pass
        meanFrac, meanErr = GetMeanAndError(fracs)
        Means[logE] = showerAverResults(logE, meanFrac, meanErr, fracs)

    return Hs, Fs, Means


########################################
########################################
########################################

class showerAverResults:
    def __init__(self, logE, mean, meanErr, means):
        self.logE = logE
        self.mean = mean
        self.meanErr = meanErr
        self.means = means
  
########################################
########################################
########################################
      

def main(argv):

    SetMyStyle()

    #logEs = [ int(pow(10,n)) for n in range(2,8)]
    #logEs = [ int(pow(10,n)) for n in range(3,6)]
    #logEs = [100, 1000, 10000, 50000, 100000, 1000000]
    #logEs.append(250000)

    logEs = [#11, 11.5,
        12, 12.5,
        13, 13.5, 14, 14.5, 15,
        15.5,
        16.0,
    ]

    cnx, cny = 3, 3
    cw, ch = 1400, 1200
    print(logEs)

    
    hbasenames = ['Nhists/Npi0', 'Nhists/Nch']
    Nshowers = 500
    fnames = {}

    if len(argv) < 2:
        print(f'Usage:   {argv[0]} rootdir [-b] (batch mode)')
        print(f'Example: {argv[0]} root_Inel_0.3_C_10.0_piExp_0.2')
        return()
    
    rootdir = argv[1]

    gBatch = False
    if len(argv) > 3 and argv[3] == '-b':
        gBatch = True
        ROOT.gROOT.SetBatch(1)

    # primary particle as generated by AirSim:
    primary = 'p'
    #primary = 'A56'
    if 'primaryEl' in rootdir:
        primary = 'e'
    for logE in logEs:
        fnames[logE] = f'{rootdir}/histos_{primary}_logE_{logE:1.1f}_tmp.root'
        
    Hs, Fs, MeansAirSim = GetHintegrals(logEs, fnames, hbasenames, Nshowers)
    ftag = fnames[logE].split('/')[-2].replace('root_','').replace('_',' ')
    fftag = ftag.replace(' ','_')
    if primary != 'p':
        ftag = ftag + ' ' + primary
        fftag = fftag + '_' + primary
        
    
    print('Got following lengths:')
    for logE in Hs:
        print(f'{logE}: {len(Hs[logE])}')
    
    gr = ROOT.TGraphErrors()
    gr.SetName('gr_EMfrac')
    ip = 0
    for logE,meanData in MeansAirSim.items():
        mean = meanData.mean
        meanErr = meanData.meanErr
        gr.SetPoint(ip, logE, mean)
        gr.SetPointError(ip, 0., meanErr)
        ip = ip+1


    H2s = []
    Hsums = []
    canname = f'CmpEMfrac'
    can = ROOT.TCanvas(canname, canname, 0, 0, cw, ch)
    cans.append(can)
    can.Divide(cnx, cny)

    ########################
    # Plot private shower profiles
    nmaxptcls = 5000

    ie = 0
    # for histograms of peak Xmax vals, to be compared to already plotted conex;-)
    HsPeakXmax = {}
    if False:
        for logE,hs in Hs.items():
            can.cd(1+ie)
            ymax = getMaxima(hs)*1.2
            h2 = ROOT.TH2D(f'tmp_{logE}', ';N;Particles (e/#pi/p)', 100, 40, nmaxptcls, 100, 0, ymax)
            h2.Draw()
            makeWhiteAxes(h2)
            H2s.append(h2)

            HsPeakXmax[logE] = ROOT.TH1D(f'AirSimPeakXmax_{logE}', ';X_{max}[g/cm^{2}];showers', 75, 0, 1500)

            h2sum = ROOT.TH2D(f'hsum_{logE}', ';x[g/cm^{2}];Particles (e/#mu)', 40, 0, nmaxptcls, 25, 0, ymax)
            makeWhiteAxes(h2sum)
            Hsums.append(h2sum)

            stxt = ROOT.TLatex(0.63, 0.68, 'Private sim.')
            stxt.SetTextColor(ROOT.kWhite)
            stxt.SetNDC()
            stxt.Draw()
            txts.append(stxt)

            txt = ROOT.TLatex(0.63, 0.82, f'logE={logE}')
            txt.SetTextColor(ROOT.kWhite)
            txt.SetNDC()
            txt.Draw()
            txts.append(txt)

            ntxt = ROOT.TLatex(0.63, 0.75, f'Showers: {len(hs)}')
            ntxt.SetTextColor(ROOT.kWhite)
            ntxt.SetNDC()
            ntxt.Draw()
            txts.append(ntxt)

            opt = ' same'
            meanMean = 0.
            # no filling by means of shower profiles,
            # but actually filling by already found Xmax vals!
            for val in MeansAirSim[logE].means:
                #for h in hs:
                #val = h.GetMean()
                meanMean += val
                HsPeakXmax[logE].Fill(val)
                #print('mean, rms: ', h.GetMean(), h.GetRMS())
            meanMean /= (1.*len(hs))
            #print('meanMean ', meanMean)
            #ROOT.gPad.BuildLegend()
            ROOT.gPad.RedrawAxis()
            #ROOT.gPad.SetGridx(1)
            #ROOT.gPad.SetGridy(1)
            ROOT.gPad.Update()

            #sumcan.cd(1+ie)
            #y1 = 1.5*h2sum.GetYaxis().GetBinWidth(1)
            #h2sum.GetYaxis().SetRangeUser(y1, h2sum.GetYaxis().GetXmax())
            #h2sum.Draw('colz')
            #ROOT.gPad.Update()

            ie += 1
            #
    ie = 0

    canname = 'GrXmean'
    gcan = ROOT.TCanvas(canname, canname, 500, 500, 800, 600)
    makeGrStyle(gr, ROOT.kAzure-3)
    gr.GetXaxis().SetTitle('log_{10}E(eV)')
    gr.GetYaxis().SetTitle('EM frac')
    gr.GetYaxis().SetRangeUser(0, 1.5)

    # private AirSim fit:
    gr.Draw('APL')
    fun = ROOT.TF1("fit", "[0] + [1]*x", 12., 20.)
    fun.SetParameters(500, 0.1)
    fun.SetLineStyle(7)
    fun.SetLineColor(gr.GetLineColor())
    fun.SetLineWidth(1)
    gr.Fit('fit')
    predict17 = fun.Eval(17.)
    print('Fit extrapolation to 10^17 eV: ', predict17)
    gr.GetYaxis().SetAxisColor(ROOT.kWhite)
    gr.GetYaxis().SetLabelColor(ROOT.kWhite)
    gr.GetYaxis().SetTitleColor(ROOT.kWhite)


    ########################
    # print
    pngdir  = 'png_tuning/'
    pdfdir  = 'pdf_tuning/'


    
    can.Print(pngdir + can.GetName() + f'_{fftag}.png')
    can.Print(pdfdir + can.GetName() + f'_{fftag}.pdf')

    gcan.Print(pngdir + gcan.GetName() + '_{fftag}.png')
    gcan.Print(pdfdir + gcan.GetName() + '_{fftag}.pdf')

    stuff.append([Hs, gr])

    print('DONE!')
        
    
    if not gBatch:
        ROOT.gApplication.Run()



###########################################################
###########################################################
###########################################################

if __name__ == "__main__":
    # execute only if run as a script"
    main(sys.argv)

###########################################################
###########################################################
###########################################################
